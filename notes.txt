argv[0]		The number of philosophers
argv[1]		The time a philosopher will die if he doesn’t eat
argv[2]		The time it takes a philosopher to eat
argv[3]		The time it takes a philosopher to sleep
argv[4]		Number of times all the philosophers need to eat before terminating the program **

** optional argument



Common deadlock prevention strategies
1. Order-based approach (most common)

If philosopher id is even: pick up right fork first, then left.

If philosopher id is odd: pick up left fork first, then right.
This prevents everyone from locking forks in the same order.

This logic goes inside the eating routine, not during initialization.


???????? TO DO ????????

┌───────────────────────────────────────────────────────────────────────────┐
│                        PHILOSOPHERS PROJECT TODO LIST                      │
└───────────────────────────────────────────────────────────────────────────┘

1. Parse and validate input
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Parse argc/argv                                               │
   │ - Convert strings to integers using ft_atoi                     │
   │ - Store values in t_program struct                               │
   │ - Optional: store number of meals                                 │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Check for non-digit input
   - Handle optional fifth argument correctly
   - Avoid overflow when converting strings

2. Initialize program
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Set death_flag = 0                                           │
   │ - Allocate forks array (one mutex per philosopher)             │
   │ - Initialize each mutex with pthread_mutex_init                │
   │ - Initialize print_mutex for synchronized output               │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Free memory if malloc fails
   - Always check return value of pthread_mutex_init
   - Mutexes must exist before threads start

3. Allocate and initialize philosophers
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Allocate array of t_philo                                     │
   │ - Assign philo_id (1 to N)                                      │
   │ - Set meal_count = 0, meal_last = 0                              │
   │ - Assign program pointer                                         │
   │ - Assign left_fork = forks[i], right_fork = forks[(i+1)%N]      │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Ensure wrap-around for right_fork (last philo gets first fork)
   - Do not forget to initialize meal_last timestamp

4. Create philosopher threads
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Loop through philosophers                                     │
   │ - Call pthread_create for each thread with philo_routine        │
   │ - Optionally stagger start for odd/even philosophers           │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Pass pointer to philosopher, not the whole array
   - Check pthread_create return values
   - Avoid race conditions during startup

5. Philosopher routine (loop)
   ┌───────────────────────────────────────────────────────────────┐
   │ Loop condition:                                               │
   │ while death_flag == 0 && (times_to_eat == -1 || meal_count < N)│
   │                                                                 │
   │ Steps:                                                         │
   │ 1. Think                                                       │
   │ 2. Take forks (mutex lock)                                     │
   │ 3. Eat                                                         │
   │ 4. Release forks (mutex unlock)                                │
   │ 5. Sleep                                                       │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Use even/odd fork picking order to avoid deadlock
   - Lock print_mutex when printing to avoid garbled output
   - Update meal_last after eating
   - Convert time to milliseconds consistently

6. Timing
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Use gettimeofday to track time                                │
   │ - Convert to milliseconds                                       │
   │ - usleep for sleeping/eating                                    │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - usleep uses microseconds, multiply milliseconds by 1000
   - Avoid sleeping too long and missing death detection

7. Death detection
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Option 1: Monitor thread checks each philo last meal time     │
   │ - Option 2: Each philosopher checks itself before eating        │
   │ - Set death_flag = 1 when someone dies                          │
   │ - Stop simulation gracefully                                    │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Always lock when reading shared variables (e.g., death_flag)
   - Print death only once
   - Unlock forks if death occurs while holding them

8. Thread joining
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Loop through philosophers and call pthread_join              │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Only join threads that were created
   - Avoid deadlock if a thread is stuck (should not happen if step 5 is correct)

9. Cleanup
   ┌───────────────────────────────────────────────────────────────┐
   │ What to do:                                                    │
   │ - Destroy all fork mutexes                                      │
   │ - Destroy print_mutex                                           │
   │ - Free forks array                                              │
   │ - Free philosophers array                                       │
   └───────────────────────────────────────────────────────────────┘
   Be careful:
   - Free only what was allocated
   - Destroy mutexes after threads have finished

10. Testing & edge cases
   ┌───────────────────────────────────────────────────────────────┐
   │ Consider:                                                      │
   │ - 1 philosopher                                                │
   │ - 2 philosophers                                               │
   │ - Odd vs even philosophers                                     │
   │ - philosophers that never eat enough                            │
   │ - Maximum times_to_eat argument                                 │
   └───────────────────────────────────────────────────────────────┘



valgrind --tool=helgrind ./philosophers 5 400 200 200
valgrind --tool=helgrind --track-lockorders=yes --history-level=full ./philosophers 5 800 200 200
valgrind -s --leak-check=full --show-leak-kinds=all --track-fds=all ./philosophers 4 400 200 200


t_program
├─ forks[N]           -> N pthread_mutex_t (shared)
├─ philos[N]          -> N t_philo
│   ├─ left_fork      -> points to forks[i]
│   ├─ right_fork     -> points to forks[(i+1)%N]
│   ├─ meal_mutex     -> protects meal_count & meal_last
│   └─ thread         -> philosopher thread
├─ print_mutex        -> protects printing
├─ death_mutex        -> protects death_flag
├─ meals_mutex        -> protects global meal count


Philosophers (philo array):

philo[0]:
    left_fork  -> &forks[0]
    right_fork -> &forks[1]

philo[1]:
    left_fork  -> &forks[1]
    right_fork -> &forks[2]

philo[2]:
    left_fork  -> &forks[2]
    right_fork -> &forks[3]

philo[3]:
    left_fork  -> &forks[3]
    right_fork -> &forks[0]  (wrap-around)
